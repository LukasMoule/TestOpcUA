<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akomi.Utilities</name>
    </assembly>
    <members>
        <member name="T:Akomi.Exceptions.MissingAttributeException">
            <summary>
            IsThrown when trying to access a missing attribute
            </summary>
        </member>
        <member name="M:Akomi.Exceptions.MissingAttributeException.#ctor(System.Type,System.Object,System.String)">
            <summary>
            Standard constructor
            </summary>
            <param name="attributeType">The type of the missing attribute</param>
            <param name="containingObject"></param>
            <param name="memberName"></param>
        </member>
        <member name="T:Akomi.Utilities.DispatchingObservableCollection`1">
            <summary> 
            This class is an observablecollection which invokes automatically.  
            This means that any change will be done in the right thread.  
            Source https://michlg.wordpress.com/2009/08/14/dispatchingobservablecollection-thread-save-observablecollection/
            </summary>  
            <typeparam name="T">The type of the elements</typeparam>  
        </member>
        <member name="F:Akomi.Utilities.DispatchingObservableCollection`1.MaxCount">
            <summary>
            After reaching this limit the first item will be dropped while adding new ones
            </summary>
        </member>
        <member name="M:Akomi.Utilities.DispatchingObservableCollection`1.#ctor">
            <summary>  
            The default constructor of the ObservableCollection  
            </summary>  
        </member>
        <member name="M:Akomi.Utilities.DispatchingObservableCollection`1.DoDispatchedAction(System.Action)">
             <summary>  
             Executes this action in the right thread  
             </summary>  
            <param name="action">The action which should be executed</param>  
        </member>
        <member name="M:Akomi.Utilities.DispatchingObservableCollection`1.ClearItems">
            <summary>  
            Clears all items  
            </summary>  
        </member>
        <member name="M:Akomi.Utilities.DispatchingObservableCollection`1.InsertItem(System.Int32,`0)">
             <summary>  
             Inserts a item at the specified index  
             </summary>  
            <param name="index">The index where the item should be inserted</param>  
            <param name="item">The item which should be inserted</param>  
        </member>
        <member name="M:Akomi.Utilities.DispatchingObservableCollection`1.MoveItem(System.Int32,System.Int32)">
             <summary>  
             Moves an item from one index to another  
             </summary>  
            <param name="oldIndex">The index of the item which should be moved</param>  
            <param name="newIndex">The index where the item should be moved</param>  
        </member>
        <member name="M:Akomi.Utilities.DispatchingObservableCollection`1.RemoveItem(System.Int32)">
             <summary>  
             Removes the item at the specified index  
             </summary>  
            <param name="index">The index of the item which should be removed</param>  
        </member>
        <member name="M:Akomi.Utilities.DispatchingObservableCollection`1.SetItem(System.Int32,`0)">
             <summary>  
             Sets the item at the specified index  
             </summary>  
            <param name="index">The index which should be set</param>  
            <param name="item">The new item</param>  
        </member>
        <member name="M:Akomi.Utilities.DispatchingObservableCollection`1.Equals(System.Collections.ObjectModel.ObservableCollection{`0})">
            <summary>
            Checks is the collections are equal
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Akomi.Utilities.Reflection">
            <summary>
            Provides utilities to reflect classes
            </summary>
        </member>
        <member name="M:Akomi.Utilities.Reflection.GetMemberDefaultValue``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Returns the property value declared by <see cref="T:System.ComponentModel.DefaultValueAttribute"/>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="expression"></param>
            <exception cref="T:Akomi.Exceptions.MissingAttributeException">If DefaultValueAttribute does not exist</exception>
            <exception cref="T:System.MissingMemberException">If member does not exist</exception>
            <example>
            type.GetPropertyDefaultValue{ISkill, string}(t => t.property);
            </example>
            <returns></returns>
        </member>
        <member name="M:Akomi.Utilities.Reflection.GetMemberDefaultValue``2(System.Type,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Returns the property value declared by <see cref="T:System.ComponentModel.DefaultValueAttribute"/>
            </summary>
            <typeparam name="T">The type used for naming template</typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="type">The actual type to reflect</param>
            <param name="expression"></param>
            <exception cref="T:Akomi.Exceptions.MissingAttributeException">If DefaultValueAttribute does not exist</exception>
            <exception cref="T:System.MissingMemberException">If member does not exist</exception>
            <example>
            type.GetPropertyDefaultValue{ISkill, string}(t => t.property);
            </example>
            <returns></returns>
        </member>
        <member name="T:Akomi.Utilities.ThreadingHelper">
            <summary>
            This class contains methods that help to manage threads
            </summary>
        </member>
        <member name="M:Akomi.Utilities.ThreadingHelper.StartInThreadWithApartmentStateAsync``1(System.Func{``0},System.Threading.ApartmentState,System.Boolean)">
            <summary>
            This Method invokes a function in a specified apartment state
            </summary>
            <param name="func">The function to invoke</param>
            <param name="apartmentState">the apartment state</param>
            <param name="isBackground">specifies if the created thread is a background thread</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Akomi.Utilities.ThreadingHelper.StartInThreadWithApartmentStateAsync(System.Action,System.Threading.ApartmentState,System.Boolean)">
            <summary>
            This Method invokes a action in a specified apartment state
            </summary>
            <param name="action">The action to invoke</param>
            <param name="apartmentState">the apartment state</param>
            <param name="isBackground">specifies if the created thread is a background thread</param>
            <returns></returns>
        </member>
        <member name="T:Akomi.Utilities.Nameof`1">
            <summary>
            Static class for getting the Name of a Method
            Source: http://stackoverflow.com/a/301957/5006592
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Akomi.Utilities.Nameof`1.Property``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})" -->
        <member name="T:Akomi.Utilities.NameOfHelper">
            <summary>
            Provides the <see cref="M:Akomi.Utilities.NameOfHelper.nameof``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})"/> extension method that works as a workarounds for a nameof() operator, 
            which should be added to C# sometime in the future.
            </summary>
        </member>
        <member name="M:Akomi.Utilities.NameOfHelper.nameof``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Returns a string represantaion of a property name (or a method name), which is given using a lambda expression.
            </summary>
            <typeparam name="T">The type of the <paramref name="obj"/> parameter.</typeparam>
            <typeparam name="TProp">The type of the property (or the method's return type), which is used in the <paramref name="expression"/> parameter.</typeparam>
            <param name="obj">An object, that has the property (or method), which its name is returned.</param>
            <param name="expression">A Lambda expression of this pattern: x => x.Property <BR/>
            Where the x is the <paramref name="obj"/> and the Property is the property symbol of x.<BR/>
            (For a method, use: x => x.Method()</param>
            <returns>A string that has the name of the given property (or method).</returns>
        </member>
        <member name="M:Akomi.Utilities.NameOfHelper.nameof``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Returns a string represantaion of a property name (or a method name), which is given using a lambda expression.
            </summary>
            <typeparam name="TProp">The type of the property (or the method's return type), which is used in the <paramref name="expression"/> parameter.</typeparam>
            <param name="expression">A Lambda expression of this pattern: () => x.Property <BR/>
            Where Property is the property symbol of x.<BR/>
            (For a method, use: () => x.Method()</param>
            <example>
            For static Method use: 
            NameOfHelper.nameof(() => MyStaticMethod(null)
            </example>
            <returns>A string that has the name of the given property (or method).</returns>
        </member>
        <member name="M:Akomi.ExtensionMethods.ArrayExtensions.SubArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            This Method create a new Subbaray from the array invoked on.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="index"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Akomi.ExtensionMethods.MemberInfoExtensions.GetDefaultValueAttributeValue(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Returns the value contained in the <see cref="T:System.ComponentModel.DefaultValueAttribute"/> Attribute of the property
            </summary>
            <exception cref="M:System.Reflection.CustomAttributeExtensions.GetCustomAttribute``1(System.Reflection.MemberInfo)"></exception>
            <param name="memberInfo"></param>
            <param name="interhit"></param>
        </member>
        <member name="M:Akomi.ExtensionMethods.MemberInfoExtensions.GetDefaultValueAttributeValue``1(System.Reflection.MemberInfo)">
            <summary>
            Returns the value contained in the <see cref="T:System.ComponentModel.DefaultValueAttribute"/> Attribute of the property
            </summary>
            <exception cref="T:System.InvalidCastException"></exception>
            <exception cref="M:Akomi.ExtensionMethods.MemberInfoExtensions.GetDefaultValueAttributeValue(System.Reflection.MemberInfo,System.Boolean)"></exception>
            <param name="memberInfo"></param>
        </member>
        <member name="M:Akomi.ExtensionMethods.MemberInfoExtensions.GetValueOrInvoke(System.Reflection.MemberInfo,System.Object)">
            <summary>
            Returns the field or property value or returns the
            Return value of a invoked Method
            </summary>
            <param name="memberInfo"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="T:Akomi.Logger.Category">
            <summary>
            Defines values for the <see cref="P:Akomi.Logger.Message.MessageType"/> used by <see cref="T:Akomi.Logger.Message"/>.
            </summary>
        </member>
        <member name="F:Akomi.Logger.Category.Debug">
            <summary>
            Debug category.
            </summary>
        </member>
        <member name="F:Akomi.Logger.Category.Exception">
            <summary>
            Exception category.
            </summary>
        </member>
        <member name="F:Akomi.Logger.Category.Info">
            <summary>
            Informational category.
            </summary>
        </member>
        <member name="F:Akomi.Logger.Category.Warn">
            <summary>
            Warning category.
            </summary>
        </member>
        <member name="T:Akomi.Logger.Logger">
            <summary>
            Eine Loggerklasse, die sämtlichen Informationsfluss an den Benutzer übernimmt
            Ob Warnings, Infos oder Errors gemeldet werden, wird von Resources.LoggingLevel bestimmt
            todo: Tests schreiben
            todo: Make Logger usable from Code without UI-Thread http://stackoverflow.com/questions/5143599/detecting-whether-on-ui-thread-in-wpf-and-winforms
            </summary>
        </member>
        <member name="E:Akomi.Logger.Logger.NewLogMessage">
            <summary>
            This event will be raised after every incoming log message
            </summary>
        </member>
        <member name="F:Akomi.Logger.Logger.ConsoleOutput">
            <summary>
            If true the Logger will print all messages to the console accordingly
            </summary>
        </member>
        <member name="P:Akomi.Logger.Logger.Mute">
            <summary>
            Falls true, gibt der Logger keine nachrichten mehr von sich und speichert diese auch nicht
            </summary>
        </member>
        <member name="P:Akomi.Logger.Logger.MaxMessageCount">
            <summary>
            This number limits the maximal amount of <see cref="T:Akomi.Logger.Message"/> objects stored in the logger
            </summary>
        </member>
        <member name="M:Akomi.Logger.Logger.Warning(System.String)">
            <summary>
            Gibt eine Warnung wieder
            </summary>
            <param name="warning"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Warning(System.String,System.Object[])">
            <summary>
            Gibt eine Warnung wieder
            Auf die Argumente wird <see cref="M:System.String.Format(System.String,System.Object[])"/> angewendet
            </summary>
            <param name="warning"></param>
            <param name="paramList"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Warning(System.Exception)">
            <summary>
            Gibt einen Exception StackTrace als Warnung wieder
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Error(System.String)">
            <summary>
            Gibt einen Fehler wieder
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Error(System.String,System.Object[])">
            <summary>
            Gibt einen Fehler wieder
            Auf die Argumente wird <see cref="M:System.String.Format(System.String,System.Object[])"/> angewendet
            </summary>
            <param name="error"></param>
            <param name="paramList"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Error(System.Exception)">
            <summary>
            Gibt einen Exception StackTrace als Fehler wieder
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Info(System.String)">
            <summary>
            Gibt eine Info wieder
            </summary>
            <param name="info"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Info(System.String,System.Object[])">
            <summary>
            Gibt eine Info wieder
            Auf die Argumente wird <see cref="M:System.String.Format(System.String,System.Object[])"/> angewendet
            </summary>
            <param name="info"></param>
            <param name="paramList"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Info(System.Exception)">
            <summary>
            Gibt einen Exception StackTrace als Info wieder
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Debug(System.String)">
            <summary>
            Gibt eine Debug-Information wieder
            </summary>
            <param name="debugInfo"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Debug(System.String,System.Object[])">
            <summary>
            Gibt eine Debug-Information wieder
            Auf die Argumente wird <see cref="M:System.String.Format(System.String,System.Object[])"/> angewendet
            </summary>
            <param name="debugInfo"></param>
            <param name="paramList"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.Debug(System.Exception)">
            <summary>
            Gibt einen Exception StackTrace als Info wieder
            </summary>
            <param name="exception"></param>
        </member>
        <member name="M:Akomi.Logger.Logger.GetCallingAssembly">
            <summary>
            Im Unterschied zu <see cref="M:System.Reflection.Assembly.GetCallingAssembly"/> gibt diese Methode die diese Assembly aufrufende Assembly zurück
            Source: http://stackoverflow.com/questions/11014280/c-sharp-getting-parent-assembly-name-of-calling-assembly
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akomi.Logger.Logger.GetCallingMethod">
            <summary>
            Returns the name of the Method, which calls the <see cref="T:Akomi.Logger.Logger"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akomi.Logger.Message">
            <summary>
            Diese Klasse representiert eine Nachrichten-Klasse, welche vom Logger verwendet wird, um Log-Nachrichten zu speichern
            </summary>
        </member>
        <member name="P:Akomi.Logger.Message.TimestampDateTime">
            <summary>
            A timestamp, when the content of the message was set last time as <see cref="T:System.DateTime"/>
            </summary>
        </member>
        <member name="P:Akomi.Logger.Message.Timestamp">
            <summary>
            A timestamp, when the content of the message was set last time
            </summary>
        </member>
        <member name="P:Akomi.Logger.Message.Module">
            <summary>
            The name of the as assembly in which the <see cref="T:Akomi.Logger.Logger"/> was called.
            </summary>
        </member>
        <member name="P:Akomi.Logger.Message.Method">
            <summary>
            The name of the Method in which the <see cref="T:Akomi.Logger.Logger"/> was called.
            </summary>
        </member>
        <member name="P:Akomi.Logger.Message.Heading">
            <summary>
            Heading for the Message.
            It contains the main information
            </summary>
        </member>
        <member name="P:Akomi.Logger.Message.Value">
            <summary>
            The content of the <see cref="T:Akomi.Logger.Message"/>
            </summary>
        </member>
        <member name="M:Akomi.Logger.Message.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Akomi.Logger.Message.#ctor(System.String,Akomi.Logger.Category,System.String,System.String)">
            <summary>
            Constructor witch properies
            </summary>
            <param name="msg"></param>
            <param name="category"></param>
            <param name="module"></param>
            <param name="method"></param>
        </member>
        <member name="P:Akomi.Logger.Message.MessageType">
            <summary>
            The <see cref="T:Akomi.Logger.Category"/> of the message is used to classify the importanze and for filtering
            </summary>
        </member>
        <member name="M:Akomi.Logger.Message.Parse(System.String)">
            <summary>
            Parses a string build thourgh <see cref="M:Akomi.Logger.Message.ToParseableString"/> into a <see cref="T:Akomi.Logger.Message"/>
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Akomi.Logger.Message.TryParse(System.String,Akomi.Logger.Message@)">
            <summary>
            Handles errors of <see cref="M:Akomi.Logger.Message.Parse(System.String)"/> with try catch.
            And return false in case of a error.
            </summary>
            <param name="input"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Akomi.Logger.Message.ToParseableString">
            <summary>
            Creates a string for the <see cref="M:Akomi.Logger.Message.Parse(System.String)"/> Method
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akomi.Logger.Message.ToString">
            <summary>
            Overrides <see cref="M:Akomi.Logger.Message.ToString"/> method
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akomi.Logger.MutedLogger">
            <summary>
            Used to mute and unmute the logger
            </summary>
        </member>
        <member name="M:Akomi.Logger.MutedLogger.#ctor">
            <summary>
            MutedLogger mutes the logger
            </summary>
        </member>
        <member name="M:Akomi.Logger.MutedLogger.Dispose">
            <summary>
            Disposing the MutedLogger will unmute the logger
            </summary>
        </member>
        <member name="M:ExtensionMethodsCollection.AssemblyExtensions.ReadEmbeddedString(System.Reflection.Assembly,System.String)">
            <summary>
            reads an string from an file with is included in an assembly as embedded resource
            </summary>
            <param name="assembly"></param>
            <param name="resourcePath"></param>
            <returns>the embedded content of the file as string</returns>
        </member>
        <member name="M:ExtensionMethodsCollection.AssemblyExtensions.TryReadEmbeddedString(System.Reflection.Assembly,System.String,System.String@)">
            <summary>
            
            </summary>
            <param name="resourceContent"></param>
            <param name="resourcePath"></param>
            <param name="assembly"></param>
            <returns>true if everything is Ok an the resource has been read, returns false on failure</returns>
        </member>
        <member name="M:ExtensionMethodsCollection.AssemblyExtensions.GetResourceStream(System.Reflection.Assembly,System.String)">
            <summary>
            Returns a <see cref="T:System.IO.Stream"/> for reading the embedded resource
            </summary>
            <param name="assembly"></param>
            <param name="resourcePath"></param>
            <returns></returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:ExtensionMethodsCollection.AssemblyExtensions.TryGetResourceStream(System.Reflection.Assembly,System.String,System.IO.Stream@)">
            <summary>
            Returns true if resource <see cref="T:System.IO.Stream"/> was loaded without any exception, false otherwise 
            </summary>
            <param name="assembly"></param>
            <param name="resourcePath"></param>
            <param name="resourceStream">The resource stream</param>
            <returns></returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:ExtensionMethodsCollection.AssemblyExtensions.TryGetResourceStream(System.Reflection.Assembly,System.String,System.IO.Stream@,System.Exception@)">
            <summary>
            Returns true if resource <see cref="T:System.IO.Stream"/> was loaded without any exception, false otherwise 
            </summary>
            <param name="assembly"></param>
            <param name="resourcePath"></param>
            <param name="resourceStream">The resource stream</param>
            <param name="error"></param>
            <returns></returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:ExtensionMethodsCollection.AssemblyExtensions.GetInAssemlyPath(System.Reflection.Assembly,System.String)">
            <summary>
            Returns the InAssemblyPath of an embedded File 
            </summary>
            <param name="assembly"></param>
            <param name="resourcePath"></param>
            <returns></returns>
        </member>
        <member name="T:ExtensionMethodsCollection.DispatcherExtensions">
            <summary>
            Extension Methods for <see cref="T:System.Windows.Threading.Dispatcher"/>
            </summary>
        </member>
        <member name="M:ExtensionMethodsCollection.DispatcherExtensions.DoDispatchedAction``1(System.Windows.Threading.Dispatcher,System.Action{``0},``0,System.Windows.Threading.DispatcherPriority)">
             <summary>  
             Executes this action in the right thread  
             </summary>
            <param name="dispatcher"></param>
            <param name="action">The action which should be executed</param>
            <param name="arguments"></param>
            <param name="dispatcherPriority"></param>  
        </member>
        <member name="M:ExtensionMethodsCollection.DispatcherExtensions.DoDispatchedAction(System.Windows.Threading.Dispatcher,System.Action,System.Windows.Threading.DispatcherPriority)">
             <summary>  
             Executes this action in the right thread  
             </summary>
            <param name="dispatcher"></param>
            <param name="action">The action which should be executed</param>
            <param name="dispatcherPriority"></param>  
        </member>
        <member name="M:ExtensionMethodsCollection.DispatcherExtensions.DoDispatchedAction``2(System.Windows.Threading.Dispatcher,System.Func{``0,``1},``0,System.Windows.Threading.DispatcherPriority)">
             <summary>  
             Executes this action in the right thread  
             </summary>
            <param name="dispatcher"></param>
            <param name="action">The action which should be executed</param>
            <param name="arguments"></param>
            <param name="dispatcherPriority"></param>  
        </member>
        <member name="M:ExtensionMethodsCollection.ExceptionExtensions.ToString(System.Exception,System.Boolean)">
            <summary>
            Custom ToString implementation of Exception
            </summary>
            <param name="exception"></param>
            <param name="deep">If true the stack trace and all inner exceptions will be returned as string</param>
            <returns></returns>
        </member>
        <member name="T:ExtensionMethodsCollection.GenericExtensions">
            <summary>
            Extensions for generic Types
            </summary>
        </member>
        <member name="M:ExtensionMethodsCollection.EnumerableExtension.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Applies a function to every element of the list.</summary>
        </member>
        <member name="T:ExtensionMethodsCollection.ObjectExtensions">
            <summary>
            This class adds Extension Methods for common object types
            </summary>
        </member>
        <member name="M:ExtensionMethodsCollection.ObjectExtensions.AssignDefaultValueAttributes(System.Object)">
            <summary>
            Parses the class the the attribute <see cref="T:System.ComponentModel.DefaultValueAttribute"/> and assigns the attribute to the marked properties
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:ExtensionMethodsCollection.ObjectExtensions.GetPropertyOrFieldValue(System.Object,System.String)">
            <summary>
            Gets the value from a field or a property
            </summary>
            <param name="instance"></param>
            <param name="memberName"></param>
            <returns></returns>
        </member>
        <member name="T:ExtensionMethodsCollection.StreamExtensions">
            <summary>
            Extends <see cref="T:System.IO.Stream"/> classes
            </summary>
        </member>
        <member name="M:ExtensionMethodsCollection.StreamExtensions.ReadFully(System.IO.Stream)">
            <summary>
            Source: http://stackoverflow.com/questions/221925/creating-a-byte-array-from-a-stream
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:ExtensionMethodsCollection.TupleExtension">
            <summary>
            Extends <see cref="T:System.Tuple`2"/> classes
            </summary>
        </member>
        <member name="M:ExtensionMethodsCollection.TupleExtension.IsNullOrEmpty``2(System.Tuple{``0,``1})">
            <summary>
            Checks if the tuple is null or empty
            </summary>
            <example>
            A example how to use IsNullOrEmpty
            <code>
            var myTuple = new tuple &lt; true, null &gt; ();
            myTuple.IsNullOrEmpty();
            </code>
            </example>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="tuple"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TupleExtension.HasANullObject``2(System.Tuple{``0,``1})">
            <summary>
            Checks if one element of the tuple is null
            </summary>
            <param name="tuple"></param>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <returns></returns>
        </member>
        <member name="T:ExtensionMethodsCollection.TypeExtensions">
            <summary>
            Extension Methods for <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetEnumerableType(System.Type,System.Int32)">
            <summary>
            Source: http://stackoverflow.com/questions/1846671/determine-if-collection-is-of-type-ienumerablet
            </summary>
            <param name="type"></param>
            <param name="genericArgumentNumber"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.HasEmptyOrDefaultConstructor(System.Type)">
            <summary>
            true if the type has a empty constructor or a constructor with only optional parameters
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.AllValuesAreEqual``2(System.Type,``0,``1,System.Boolean,System.Boolean)">
            <summary>
            Checks if all contained properties of a object is equal to the porperties of another object
            the checked properties come from <paramref name="type"/>
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="type">Only properties of this type are checkt for equality</param>
            <param name="object1">The first object</param>
            <param name="object2">The second object</param>
            <param name="deep">If true only primitive types are checked. The objects are parsed recursively to their primitive types</param>
            <param name="safe">If checked properties which cannot be read are skipped</param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetCustomAttributesIncludingBaseInterfaces``1(System.Type)">
            <summary>
            This is the refactored version of <see cref="M:ExtensionMethodsCollection.TypeExtensions.GetCustomAttributes(System.Type,System.Type,System.Boolean)"/>
            todo: Just use this function and dispose the rest
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.WhereTypesWithCustomAttributes(System.Collections.Generic.IEnumerable{System.Type},System.Collections.Generic.IEnumerable{System.Attribute})">
            <summary>
            Get a <see cref="T:System.Collections.Generic.IEnumerable`1"/> of all Types with the given Attributes
            </summary>
            <param name="types"></param>
            <param name="attributes"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.HasCustomAttributes(System.Reflection.ICustomAttributeProvider,System.Collections.Generic.IEnumerable{System.Attribute})">
            <summary>
            Returns a bool that says if the give <see cref="T:System.Type"/> has all the given <see cref="T:System.Attribute"/>s
            </summary>
            <param name="type"></param>
            <param name="attributes"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.HasCustomAttributes(System.Reflection.ICustomAttributeProvider,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Returns a bool that says if the given <see cref="T:System.Type"/> has all the given <see cref="T:System.Type"/>s as Attributes
            </summary>
            <param name="type"></param>
            <param name="attributeTypes"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetCustomAttributes``1(System.Type)">
            <summary>Searches and returns attributes. The inheritance chain is not used to find the attributes.</summary>
            <typeparam name="T">The type of attribute to search for.</typeparam>
            <param name="type">The type which is searched for the attributes.</param>
            <returns>Returns all attributes.</returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetCustomAttributes``1(System.Type,System.Boolean)">
            <summary>Searches and returns attributes.</summary>
            <typeparam name="T">The type of attribute to search for.</typeparam>
            <param name="type">The type which is searched for the attributes.</param>
            <param name="inherit">Specifies whether to search this member's inheritance chain to find the attributes. Interfaces will be searched, too.</param>
            <returns>Returns all attributes.</returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetParameterlessConstructor(System.Type)">
            <summary>
            Returns a constructor of <paramref name="type"/> which has no parameters.
            </summary>
            <param name="type"></param>
            <returns>null if no parameterless constructor exists, otherwise the instance of the <see cref="T:System.Reflection.ConstructorInfo"/></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetCustomAttributes(System.Type,System.Type,System.Boolean)">
            <summary>Private helper for searching attributes.</summary>
            <param name="type">The type which is searched for the attribute.</param>
            <param name="attributeType">The type of attribute to search for.</param>
            <param name="inherit">Specifies whether to search this member's inheritance chain to find the attribute. Interfaces will be searched, too.</param>
            <returns>An array that contains all the custom attributes, or an array with zero elements if no attributes are defined.</returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.IsSubclassOfRawGeneric(System.Type,System.Type)">
            <summary>
            Returns true if the type is subclass of the generic parameter type
            Source: http://stackoverflow.com/questions/457676/check-if-a-class-is-derived-from-a-generic-class
            </summary>
            <param name="generic"></param>
            <param name="toCheck"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetUnhiddenMembers``1(System.Type,System.Collections.Generic.List{``0},System.Reflection.BindingFlags)">
            <summary>
            Returns all Properties of a <see cref="T:System.Type"/> except the hidden ones.
            </summary>
            <param name="type"></param>
            <param name="members"></param>
            <param name="bindingFlags"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetUnhiddenMember``1(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Returns a property that is not hidden. Used for ambigious references and reflection.
            </summary>
            <param name="type"></param>
            <param name="propertyName"></param>
            <param name="bindingFlags"></param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetGenericBaseType(System.Type)">
            <summary>
            Searches in derivation hierarchy recursively for the next generic type.
            <para>The call will be delegated to <see cref="M:ExtensionMethodsCollection.TypeExtensions.TryGetGenericBaseType(System.Type,System.Type@)"/></para>
            
            </summary>
            <param name="type"></param>
            <exception cref="T:System.InvalidOperationException">Thrown if no basetype has been found</exception>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.TryGetGenericBaseType(System.Type,System.Type@)">
            <summary>
            Searches in derivation hierarchy recursively for a generic type
            </summary>
            <param name="type"></param>
            <param name="baseType">the nearest generic baseType</param>
            <returns></returns>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.AssignDefaultValueAttributes(System.Type)">
            <summary>
            Assigns Default values in static objects
            </summary>
            <param name="staticTarget"></param>
        </member>
        <member name="M:ExtensionMethodsCollection.TypeExtensions.GetPropertyOrField(System.Type,System.String,System.Reflection.MemberInfo@)">
            <summary>
            Gets the value from a field or a property
            </summary>
            <param name="type"></param>
            <param name="memberName"></param>
            <param name="memberInfo">the reflected member Info</param>
            <returns>
            <see cref="T:System.Reflection.MemberTypes"/> of <paramref name="memberInfo"/> 
            <para/>
            0 - If field not found
            </returns>
        </member>
        <member name="M:Beatshake.ExtensionMethods.PrimitiveExtensions.IsAlmostZero(System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <param name="tol"></param>
            <returns>True if the abs of the give value is lower or equal <paramref name="tol"/></returns>
        </member>
        <member name="M:Beatshake.ExtensionMethods.PrimitiveExtensions.NextLower(System.Double)">
            <summary>
            Returns the next lower double value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Beatshake.ExtensionMethods.PrimitiveExtensions.NextGreater(System.Double)">
            <summary>
            Returns the next greate double value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Beatshake.ExtensionMethods.PrimitiveExtensions.FastPower(System.Double,System.UInt32)">
            <summary>
            Powers the given double.
            This Method should be faster than <see cref="M:System.Math.Pow(System.Double,System.Double)"/> (unvalidated)
            </summary>
            <param name="value"></param>
            <param name="exp"></param>
            <returns></returns>
        </member>
    </members>
</doc>
